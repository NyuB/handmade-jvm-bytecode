import unittest
import jvm_class
import os
import shutil

class BaseTestClass(unittest.TestCase):

    java_compilation_test_class_name = "CraftedClassCompiledTest"
    java_compilation_test_source = f"tests/java/{java_compilation_test_class_name}.java"
    java_class_loader_test_class_name = "CraftedClassLoadTest"
    java_class_loader_test_source = f"tests/java/{java_class_loader_test_class_name}.java"

    def __init__(self, methodName: str):
        super().__init__(methodName)
        self.output_classes = self.get_output_classes()
        self.output_class = os.path.join(self.output_classes, f"{self.get_output_class_name()}.class")

    def get_output_classes(self) -> str:
        raise NotImplementedError(self.get_output_classes.__name__ + " must be implemented by actual test case")
    
    def get_output_class_name(self) -> str:
        raise NotImplementedError(self.get_output_class_name.__name__ + " must be implemented by actual test case")

    def assert_command_success(self, cmd: str) -> None:
        exit_code = os.system(cmd)
        self.assertEqual(exit_code, 0, f"Command ${cmd} failed with exit code {exit_code}")
    
    def write_class_file(self) -> None:
        raise NotImplementedError(self.write_class_file.__name__ + " must be implemented by actual test case")
    
    def setUp(self) -> None:
        try:
            os.makedirs(self.output_classes)
        except FileExistsError:
            pass
        self.write_class_file()
    
    def tearDown(self) -> None:
        try:
            shutil.rmtree(self.output_classes)
        except FileNotFoundError:
            pass

class PythonJvmClassTest(BaseTestClass):

    def get_output_classes(self) -> str:
        return "tests/py_test_classes"

    def write_bytes(self, f: str, b: list[bytes]):
        with open(f, 'ab') as file:
            for chunk in b:
                file.write(chunk)

    def get_output_class_name(self) -> str:
        return jvm_class.jvm_class_name

    def write_class_file(self) -> None:
        self.write_bytes(self.output_class, jvm_class.jvm_class_bytes())

    def test_valid_classfile_format(self):
        javap = f"javap -c -v {self.output_class}"
        self.assert_command_success(javap)

    def test_compile_with_java(self):
        javac = f"javac -cp {self.output_classes} -d {self.output_classes} {self.java_compilation_test_source}"
        self.assert_command_success(javac)

    def test_run_with_java(self):
        # Given a java source compiled with the generated classfile
        javac = f"javac -cp {self.output_classes} -d {self.output_classes} {self.java_compilation_test_source}"
        self.assert_command_success(javac)

        # When running the main java class, Then it should complete without error
        java = f"java -ea -cp {self.output_classes} {self.java_compilation_test_class_name}"
        self.assert_command_success(java)
    
    def test_run_with_java_class_loader(self):
        # Given a compiled java program using dynamic class loader 
        javac = f"javac -d {self.output_classes} {self.java_class_loader_test_source}"
        self.assert_command_success(javac)

        # When calling the main on the generated class file then it should be able to load the generated class and complete without error
        java = f"java -ea -cp {self.output_classes} {self.java_class_loader_test_class_name} {self.output_classes} {jvm_class.jvm_class_name}"
        self.assert_command_success(java)

class ScalaJvmClassTest(BaseTestClass):

    def get_output_classes(self) -> str:
        return "tests/scala_test_classes"
    
    def get_output_class_name(self) -> str:
        return "Crafted"

    def write_class_file(self) -> None:
        # Compile the scala bytecode generator class
        scalac = f"scalac -d {self.output_classes} JvmClass.scala"
        self.assert_command_success(scalac)
        # Run the bytecode generator
        writeBytes = f"scala -cp {self.output_classes} writeBytes {self.output_class}"
        self.assert_command_success(writeBytes)

    def test_valid_classfile_format(self):
        # The generated bytecode should be a valid classfile
        javap = f"javap -c -v {self.output_class}"
        self.assert_command_success(javap)
